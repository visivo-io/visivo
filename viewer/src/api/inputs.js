import { getUrl } from '../contexts/URLContext';

/**
 * Validates an input metadata object has the required structure
 * @param {Object} input - Input object to validate
 * @returns {boolean} True if valid
 */
const validateInputStructure = input => {
  if (!input.name) {
    return false;
  }

  // Must have type and structure
  if (!input.type || !input.structure) {
    return false;
  }

  // files must be an array (can be empty for static inputs)
  if (!Array.isArray(input.files)) {
    return false;
  }

  // Validate file structure if files exist
  for (const file of input.files) {
    if (!file.name_hash) {
      return false;
    }
    if (!file.signed_data_file_url) {
      return false;
    }
  }

  return true;
};

/**
 * Fetch inputs metadata with retry logic
 * @param {string} projectId - Project ID
 * @param {string[]} names - Array of input names
 * @param {number} retries - Number of retries (default 3)
 * @param {number} retryDelay - Delay between retries in ms (default 1000)
 * @returns {Promise<Object[]>} Array of input metadata objects
 */
export const fetchInputs = async (projectId, names, retries = 3, retryDelay = 1000) => {
  // In server mode, this will call /api/inputs/ with input names as query params
  // In dist mode, this will fetch /data/inputs.json

  if (!names || names.length === 0) {
    return [];
  }

  let url = getUrl('inputsQuery');
  const params = [];

  // Add input names as query parameters for server mode
  names.forEach(name => params.push(`input_names=${encodeURIComponent(name)}`));

  if (projectId) {
    params.push(`project_id=${encodeURIComponent(projectId)}`);
  }

  if (params.length > 0) {
    url += `?${params.join('&')}`;
  }

  let lastError;
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `Failed to fetch inputs data: ${response.status} ${response.statusText}. ${errorText}`
        );
      }

      const data = await response.json();

      // Ensure data is in the expected format
      let inputs = Array.isArray(data) ? data : [data];

      // Filter to only requested names (for dist mode which returns all inputs)
      const requestedNames = new Set(names);
      inputs = inputs.filter(input => requestedNames.has(input.name));

      // Validate each input
      const validInputs = inputs.filter(input => validateInputStructure(input));

      return validInputs;
    } catch (error) {
      lastError = error;

      if (attempt < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }

  throw new Error(`Failed to fetch inputs after ${retries} attempts: ${lastError.message}`);
};

/**
 * Fetch the URL for input options JSON file (legacy method for backward compatibility)
 *
 * @param {string} projectId - Project ID (unused in local mode, but kept for API compatibility)
 * @param {string} inputHash - MD5 hash of the input name (generated by backend)
 * @returns {Promise<string>} - URL to the JSON file containing input options
 */
export const fetchInputOptions = async (projectId, inputHash) => {
  // In dist mode: /data/inputs/{hash}.json
  // In server mode: /data/inputs/{hash}.json
  const url = getUrl('inputData', { hash: inputHash });
  return url;
};

/**
 * Input metadata structure (new parquet-based format)
 * @typedef {Object} InputMetadata
 * @property {string} name - Name of the input
 * @property {string} id - ID of the input (same as name)
 * @property {Array<{name_hash: string, signed_data_file_url: string, key: string}>} files - Parquet file references
 * @property {'single-select'|'multi-select'} type - Input type
 * @property {'options'|'range'} structure - Data structure type
 * @property {Object|null} static_props - Static data (options array or range config)
 * @property {Object} display - Display configuration
 * @property {string[]} warnings - Array of warning messages
 */

/**
 * Load input data from JSON file URL (legacy method for backward compatibility)
 *
 * This function fetches the JSON file and returns the parsed input data structure.
 * The JSON file contains the input configuration including options or range data.
 *
 * @param {string} url - URL to the JSON file
 * @returns {Promise<Object>} - Parsed input data
 */
export const loadInputData = async url => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch input JSON: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  return data;
};
